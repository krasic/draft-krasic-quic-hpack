<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Header Compression for HTTP over QUIC</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 QCRAM overview"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Example of HoL blocking"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 How QCRAM minimizes HoL blocking"/>
<link href="#rfc.section.3" rel="Chapter" title="3 HTTP over QUIC mapping extensions"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 HEADERS and PUSH_PROMISE"/>
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 HEADER_ACK"/>
<link href="#rfc.section.4" rel="Chapter" title="4 HPACK extensions"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Header Block Prefix"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Hybrid absolute-relative indexing"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Preventing Eviction Races"/>
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Blocked Evictions"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Handling Stream Resets"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Refreshing Entries with Duplication"/>
<link href="#rfc.section.4.5.1" rel="Chapter" title="4.5.1 Mandatory Entry De-duplication"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Performance considerations"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Speculative table updates"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Fixed overhead."/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Co-ordinated Packetization"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 IANA Considerations"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="9 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.2 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Krasic, C." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-krasic-quic-qcram-03" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-12-13" />
  <meta name="dct.abstract" content="The design of the core QUIC transport and the mapping of HTTP semantics over it subsume many HTTP/2 features, prominent among them stream multiplexing and HTTP header compression.  A key advantage of the QUIC transport is it provides stream multiplexing free of HoL blocking between streams, while in HTTP/2 multiplexed streams can suffer HoL blocking primarily due to HTTP/2&#8217;s layering above TCP. However if HPACK is used for header compression, HTTP over QUIC is still vulnerable to HoL blocking, because of how HPACK exploits header redundancies between multiplexed HTTP transactions.  This draft defines QCRAM, a variation of HPACK and mechanisms in the QUIC HTTP mapping that allow QUIC implementations the flexibility to avoid header-compression induced HoL blocking." />
  <meta name="description" content="The design of the core QUIC transport and the mapping of HTTP semantics over it subsume many HTTP/2 features, prominent among them stream multiplexing and HTTP header compression.  A key advantage of the QUIC transport is it provides stream multiplexing free of HoL blocking between streams, while in HTTP/2 multiplexed streams can suffer HoL blocking primarily due to HTTP/2&#8217;s layering above TCP. However if HPACK is used for header compression, HTTP over QUIC is still vulnerable to HoL blocking, because of how HPACK exploits header redundancies between multiplexed HTTP transactions.  This draft defines QCRAM, a variation of HPACK and mechanisms in the QUIC HTTP mapping that allow QUIC implementations the flexibility to avoid header-compression induced HoL blocking." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">QUIC</td>
  <td class="right">C. Krasic</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">December 13, 2017</td>
</tr>
<tr>
  <td class="left">Expires: June 16, 2018</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Header Compression for HTTP over QUIC<br />
  <span class="filename">draft-krasic-quic-qcram-03</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>The design of the core QUIC transport and the mapping of HTTP semantics over it subsume many HTTP/2 features, prominent among them stream multiplexing and HTTP header compression.  A key advantage of the QUIC transport is it provides stream multiplexing free of HoL blocking between streams, while in HTTP/2 multiplexed streams can suffer HoL blocking primarily due to HTTP/2&#8217;s layering above TCP. However if HPACK is used for header compression, HTTP over QUIC is still vulnerable to HoL blocking, because of how HPACK exploits header redundancies between multiplexed HTTP transactions.  This draft defines QCRAM, a variation of HPACK and mechanisms in the QUIC HTTP mapping that allow QUIC implementations the flexibility to avoid header-compression induced HoL blocking.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 16, 2018.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">QCRAM overview</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Example of HoL blocking</a></li>
<li>2.2.   <a href="#rfc.section.2.2">How QCRAM minimizes HoL blocking</a></li>
</ul><li>3.   <a href="#rfc.section.3">HTTP over QUIC mapping extensions</a></li>
<ul><li>3.1.   <a href="#rfc.section.3.1">HEADERS and PUSH_PROMISE</a></li>
<li>3.2.   <a href="#rfc.section.3.2">HEADER_ACK</a></li>
</ul><li>4.   <a href="#rfc.section.4">HPACK extensions</a></li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Header Block Prefix</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Hybrid absolute-relative indexing</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Preventing Eviction Races</a></li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Blocked Evictions</a></li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Handling Stream Resets</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Refreshing Entries with Duplication</a></li>
<ul><li>4.5.1.   <a href="#rfc.section.4.5.1">Mandatory Entry De-duplication</a></li>
</ul></ul><li>5.   <a href="#rfc.section.5">Performance considerations</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Speculative table updates</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Fixed overhead.</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Co-ordinated Packetization</a></li>
</ul><li>6.   <a href="#rfc.section.6">Security Considerations</a></li>
<li>7.   <a href="#rfc.section.7">IANA Considerations</a></li>
<li>8.   <a href="#rfc.section.8">Acknowledgments</a></li>
<li>9.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">The QUIC transport protocol was designed from the outset to support HTTP semantics, and its design subsumes most of the features of HTTP/2.  Two of those features, stream multiplexing and header compression come into some conflict in QUIC.  A key goal of the design of QUIC is to improve stream multiplexing relative to HTTP/2, by eliminating HoL (head of line) blocking that can occur in HTTP/2.  HoL blocking can happen because HTTP/2 streams are multiplexed onto a single TCP connection with its in-order semantics.  QUIC can maintain independence between streams because it implements core transport functionality in a fully stream-aware manner.  However, the HTTP over QUIC mapping is still subject to HoL blocking if HPACK is used directly as in HTTP/2.  HPACK exploits multiplexing for greater compression, shrinking the representation of headers that have appeared earlier on the same connection.  In the context of QUIC, this imposes a vulnerability to HoL blocking as will be described more below (<a href="#hol-example">Section 2.1</a>).</p>
<p id="rfc.section.1.p.2">QUIC is described in <a href="#QUIC-TRANSPORT">[QUIC-TRANSPORT]</a>.  The HTTP over QUIC mapping is described in <a href="#QUIC-HTTP">[QUIC-HTTP]</a>. For a full description of HTTP/2, see <a href="#RFC7540">[RFC7540]</a>.  The description of HPACK is <a href="#RFC7541">[RFC7541]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#qcram-overview" id="qcram-overview">QCRAM overview</a></h1>
<p id="rfc.section.2.p.1">Readers may wish to refer to <a href="#RFC7541">[RFC7541]</a> Section 1.3 to review HPACK terminology, and <a href="#QUIC-HTTP">[QUIC-HTTP]</a>, Sections 4 on &#8220;HTTP over QUIC stream mapping&#8221; and 4.2.1 on &#8220;Header Compression&#8221;.  QCRAM extensions to HPACK allow correctness in the presence of out-of-order delivery, with flexibility to balance between resilience against HoL blocking and compression ratio.</p>
<p id="rfc.section.2.p.2">QCRAM is intended to be a relatively non-intrusive extension to HPACK, an implementation should be easily shared within stacks supporting both HTTP/2 over (TLS+)TCP and HTTP over QUIC.</p>
<h2 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#hol-example" id="hol-example">Example of HoL blocking</a></h2>
<p id="rfc.section.2.1.p.1">The following is an example of how HPACK can induce HoL blocking in QUIC. Assume two HTTP message exchange streams <samp>A</samp> and <samp>B</samp>, and corresponding header blocks <samp>HA</samp> and <samp>HB</samp>. Stream <samp>B</samp> experiences HoL blocking due to <samp>A</samp> as follows:</p>
<p/>

<ol>
  <li>HPACK encodes header field <samp>HB[i]</samp> using an index that refers to a table entry that resulted from header field <samp>HA[j]</samp>.</li>
  <li><samp>HA</samp> and <samp>HB</samp> are delivered via distinct packets that are inflight in the same round trip.</li>
  <li><samp>HB</samp>&#8217;s packet is delivered but <samp>HA</samp>&#8217;s is dropped.  HPACK can not decode <samp>HB</samp> until <samp>HA</samp>&#8217;s packet is successfully retransmitted.</li>
</ol>
<h2 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#overview-hol-avoidance" id="overview-hol-avoidance">How QCRAM minimizes HoL blocking</a></h2>
<p id="rfc.section.2.2.p.1">Continuing the example, QCRAM&#8217;s approach is as follows.</p>
<p/>

<ol>
  <li><samp>HB[i]</samp> will not introduce HoL blocking if <samp>HA</samp> has been acknowledged, otherwise it is vulnerable.  A new HQ frame type HEADERS_ACK is defined (see <a href="#hq-frames">Section 3</a>).  When the decoder has processed a header block, HEADERS_ACK is sent from the decoder back to the encoder.</li>
</ol>
<p id="rfc.section.2.2.p.3">The encoder can choose on a per header block basis whether to favor higher compression ratio or HoL resilience, signaled by the BLOCKING flag in HEADERS and PUSH_PROMISE frames (see <a href="#hq-frames">Section 3</a>).</p>
<p id="rfc.section.2.2.p.4">If HB contains no vulnerable header fields, BLOCKING MUST be 0.</p>
<p id="rfc.section.2.2.p.5">If BLOCKING is set, then for each <samp>HB[i]</samp> that is vulnerable :</p>
<p/>

<ol>
  <li><samp>HB[i]</samp> is represented with one of the Literal variants (see <a href="#RFC7541">[RFC7541]</a> Section 6.2), trading lower compression ratio for HoL resilience.</li>
</ol>
<p id="rfc.section.2.2.p.7">If BLOCKING is not set then HB is encoded in blocking mode:</p>
<p/>

<ol>
  <li><samp>HB[i]</samp> is represented with an Indexed Representation.  This favors compression ratio.</li>
</ol>
<p id="rfc.section.2.2.p.9">In blocking mode, after reading HB&#8217;s prefix stream B might block.  Stream B proceeds with reading and processing the rest of HB only when all HB&#8217;s dependencies are satisfied.  The header prefix contains table offset information that establishes total ordering among all headers, regardless of reordering in the transport (see <a href="#absolute-index">Section 4.1</a>).  In blocking mode, the prefix additionally identifies the largest (absolute) index I that HB depends on (see <samp>Depends</samp> in Section <a href="#overview-absolute">Section 4.2</a>).  HB&#8217;s dependencies are satisfied when all entries less than or equal to I have been inserted into the table.  Notice that while blocked, HB&#8217;s header field data remains in the stream&#8217;s flow control window.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#hq-frames" id="hq-frames">HTTP over QUIC mapping extensions</a></h1>
<h2 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#headers-and-pushpromise" id="headers-and-pushpromise">HEADERS and PUSH_PROMISE</a></h2>
<p id="rfc.section.3.1.p.1">HEADER and PUSH_PROMISE frames define a new flag BLOCKING (0x01): Indicates the stream might need to wait for dependent headers before processing.  If 0, the header can always be processed immediately upon receipt.</p>
<h2 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a> <a href="#headerack" id="headerack">HEADER_ACK</a></h2>
<p id="rfc.section.3.2.p.1">The HEADER_ACK frame (type=0x8) is sent by the decoder side to the encoder when a the decoder has fully processed a header block.  It is used by the encoder to determine whether subsequent indexed representations that might reference that block are vulnerable to HoL blocking.  The HEADER_ACK frame does not define any flags, and has no payload.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#hpack-extensions" id="hpack-extensions">HPACK extensions</a></h1>
<h2 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> <a href="#absolute-index" id="absolute-index">Header Block Prefix</a></h2>
<p id="rfc.section.4.1.p.1">In HEADERS and PUSH_PROMISE frames, HPACK Header data are prefixed by a pair of integers pair of integers: <samp>Fill</samp> and the <samp>Evictions</samp>. <samp>Fill</samp> is the number of entries in the table, and <samp>Evictions</samp> is the cumulative number entries that have been evicted from the table.  Their sum is the cumulative number of entries inserted before the following header block was encoded.  Each is encoded as a single HPACK integer (8-bit prefix):</p>
<div id="rfc.figure.1"/>
<div id="fig-base-index"/>
<pre>
    0 1 2 3 4 5 6 7 
   +-+-+-+-+-+-+-+-+
   |Fill       (8+)|
   +---------------+
   |Evictions  (8+)|
   +---------------+
</pre>
<p class="figure">Figure 1: Absolute indexing (BLOCKING=0x0)</p>
<p><a href="#overview-absolute">Section 4.2</a> describes the role of <samp>Fill</samp> and <a href="#evictions">Section 4.3</a> covers the role of <samp>Evictions</samp>.</p>
<p id="rfc.section.4.1.p.3">When BLOCKING flag is 0x1, a the prefix additionally contains a third HPACK integer (8-bit prefix) &#8216;Depends&#8217;:</p>
<div id="rfc.figure.2"/>
<div id="fig-prefix-long"/>
<pre>
    0 1 2 3 4 5 6 7 
   +-+-+-+-+-+-+-+-+
   |Fill       (8+)|
   +---------------+
   |Evictions  (8+)|
   +---------------+
   |Depends    (8+)|
   +---------------+
</pre>
<p class="figure">Figure 2: Absolute indexing (BLOCKING=0x1)</p>
<p id="rfc.section.4.1.p.4">Depends is used to identify header dependencies, namely the largest table entry referred to by (indexed representations within) the following header block, its usage is described in <a href="#overview-hol-avoidance">Section 2.2</a>.  The largest entry index is <samp>Evictions + Fill - Depends</samp>.</p>
<h2 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> <a href="#overview-absolute" id="overview-absolute">Hybrid absolute-relative indexing</a></h2>
<p id="rfc.section.4.2.p.1">HPACK indexed entries refer to an entry by its current position in the dynamic table.  As <a href="https://tools.ietf.org/html/rfc7541#section-2.3.3">Figure 1 of RFC7541</a> illustrates, newest entries have smallest indices, and oldest entries are evicted first if the table is full.  Under this scheme, each insertion to the table causes the index of all existing entries to change (implicitly).  Implicit index updates are acceptable for HTTP/2 because TCP is totally ordered, but it is is problematic in the out-of-order context of QUIC.</p>
<p id="rfc.section.4.2.p.2">QCRAM uses a hybrid absolute-relative indexing approach.  The prefix defined in <a href="#absolute-index">Section 4.1</a> is used by the decoder to interpret all subsequent HPACK instructions at absolute positions for indexed lookups and insertions.</p>
<p id="rfc.section.4.2.p.3">Since QCRAM handles blocking at the stream level, it is an error if the HPACK decoder encounters an indexed representation that refers to an entry missing from the table, and the connection MUST be closed with the <samp>HTTP_HPACK_DECOMPRESSION_FAILED</samp> error code.</p>
<h2 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> <a href="#evictions" id="evictions">Preventing Eviction Races</a></h2>
<p id="rfc.section.4.3.p.1">Due to out of order arrival, QCRAM&#8217;s eviction algorithm requires changes (relative to HPACK) to avoid the possibility that an indexed representation is decoded after the referenced entry is already evicted.  QCRAM employs a two-phase eviction algorithm, in which the encoder will not evict entries that have outstanding (unacknowledged) references.  The QCRAM encoder maintains a counter as entries are evicted, which is the cumulative number of evictions so far, <samp>Evictions</samp> (<a href="#absolute-index">Section 4.1</a>).  On arrival at the decoder, if <samp>Evictions</samp> is higher than previously seen, the decoder MUST evict all entries at or below.  Unlike HPACK where the decoder follows the same logic as the encoder to perform evictions, in QCRAM the decoder evicts exclusively based on the encoder&#8217;s explicit guidance.</p>
<h3 id="rfc.section.4.3.1"><a href="#rfc.section.4.3.1">4.3.1.</a> <a href="#blocked-evictions" id="blocked-evictions">Blocked Evictions</a></h3>
<p id="rfc.section.4.3.1.p.1">In some cases, the encoder must forgo eviction by selecting a literal representation (blocked eviction), namely in the event that the entry subject to eviction <em>is</em> referenced by one or more unacknowledged header frames. To assure that the blocked eviction case is rare, a form of thresholding MAY be applied that constrains selection of Indexed representations, such that the oldest entries in the dynamic table will largely be evictable.  The constraint is applied when encoding header fields: comparing the cumulative position (in bytes) of the matching entry to a threshold, categorizing oldest entries (past threshold) as at-risk.  Avoiding references to at-risk entries, the encoder SHOULD use an Indexed-Duplicate representation instead (see <a href="#indexed-duplicate">Section 4.5</a>).</p>
<h2 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> <a href="#handling-stream-resets" id="handling-stream-resets">Handling Stream Resets</a></h2>
<p id="rfc.section.4.4.p.1">The QCRAM encoder has the option to select representations that might require blocking (<a href="#overview-hol-avoidance">Section 2.2</a> case 3), but the decoder must be prevented from becoming hung if the stream associated with the referenced entry is reset.  On stream reset, the QCRAM encoder MUST check if the stream has unacknowledged headers, and if so resend them on the Control Stream (<a href="#QUIC-HTTP">[QUIC-HTTP]</a> Section 4.1).  If header blocks are resent on the control stream, duplicate arrivals are possible due to reset-acknowledgment races.  The decoder MUST ignore duplicate header block arrivals, which is straightforward because of unambiguous indexing (see <a href="#overview-absolute">Section 4.2</a>).</p>
<h2 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> <a href="#indexed-duplicate" id="indexed-duplicate">Refreshing Entries with Duplication</a></h2>
<div id="rfc.figure.3"/>
<div id="fig-index-with-duplication"/>
<pre>
    0 1 2 3 4 5 6 7 
   +-+-+-+-+-+-+-+-+
   |0|0|1|Index(5+)|
   +-+-+-+---------+
</pre>
<p class="figure">Figure 3: Indexed Header Field with Duplication</p>
<p><em>Indexed-Duplicates</em> are treated as an Indexed Header Field Representation (see <a href="#RFC7541">[RFC7541]</a> Section 6.1), additionally inserting a new duplicate entry.  <a href="#RFC7541">[RFC7541]</a> allows duplicate HPACK table entries, that is entries that have the same name and value.</p>
<p>
  <em>Figure 2 annexes the representation for HPACK Dynamic Table Size Update (see Section 6.3 of RFC7541), which is not supported by HTTP over QUIC.</em>
</p>
<h3 id="rfc.section.4.5.1"><a href="#rfc.section.4.5.1">4.5.1.</a> <a href="#de-duplication" id="de-duplication">Mandatory Entry De-duplication</a></h3>
<p id="rfc.section.4.5.1.p.1">To help mitigate memory consumption due to duplicate entries, HPACK for QCRAM is required to de-duplicate strings in the dynamic table. The table insertion logic should check if the new entry matches any existing entries (name and value), and if so, table accounting MUST charge only the overhead portion (<a href="#RFC7541">[RFC7541]</a> Section 4.1) to the new entry.</p>
<p id="rfc.section.4.5.1.p.2">Specific de-duplication mechanisms are left to implementations, but using a map in conjunction with reference counted pointers to strings would be typical.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#performance-considerations" id="performance-considerations">Performance considerations</a></h1>
<h2 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#speculative-updates" id="speculative-updates">Speculative table updates</a></h2>
<p id="rfc.section.5.1.p.1">Implementations can <em>speculatively</em> send header frames on the HTTP Connection Control Stream.  Such headers would not be associated with any HTTP transaction, but could be used strategically to improve performance.  For instance, the encoder might decide to <em>refresh</em> by sending Indexed-Duplicate representations for popular header fields (<a href="#absolute-index">Section 4.1</a>), ensuring they have small indices and hence minimal size on the wire.</p>
<h2 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#fixed-overhead" id="fixed-overhead">Fixed overhead.</a></h2>
<p id="rfc.section.5.2.p.1">HPACK defines overhead as 32 bytes (<a href="#RFC7541">[RFC7541]</a> Section 4.1).  QCRAM adds some per-entry state, to track acknowledgment status and eviction reference count, and requires mechanisms to de-duplicate strings.  A larger value than 32 might be more accurate for QCRAM.</p>
<h2 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#co-ordinated-packetization" id="co-ordinated-packetization">Co-ordinated Packetization</a></h2>
<p id="rfc.section.5.3.p.1">In <a href="#overview-hol-avoidance">Section 2.2</a> case 3, an exception exists when the representation of <samp>HA[i]</samp> and <samp>HB[j]</samp> are delivered within the same transport packet.  If so, there is no risk of HoL blocking and using an indexed representation is strictly better than using a literal.  An implementation could exploit this exception by employing co-ordination between QCRAM compression and QUIC transport packetization.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.6.p.1">TBD.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.7.p.1">This document currently makes no request of IANA, and might not need to.</p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.8.p.1">This draft draws heavily on the text of <a href="#RFC7541">[RFC7541]</a>.  The indirect input of those authors is gratefully acknowledged, as well as ideas from:</p>
<p/>

<ul>
  <li>Mike Bishop</li>
  <li>Patrick McManus</li>
  <li>Biren Roy</li>
  <li>Alan Frindell</li>
  <li>Ian Swett</li>
  <li>Ryan Hamilton</li>
</ul>
<h1 id="rfc.references"><a href="#rfc.references">9.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="QUIC-HTTP">[QUIC-HTTP]</b>
      </td>
      <td class="top"><a title="Microsoft">Bishop, M.</a>, "<a>Hypertext Transfer Protocol (HTTP) over QUIC</a>", December 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC-TRANSPORT">[QUIC-TRANSPORT]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a>QUIC: A UDP-Based Multiplexed and Secure Transport</a>", December 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7540">[RFC7540]</b>
      </td>
      <td class="top"><a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="http://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC7541">[RFC7541]</b>
      </td>
      <td class="top"><a>Peon, R.</a> and <a>H. Ruellan</a>, "<a href="http://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>", RFC 7541, DOI 10.17487/RFC7541, May 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Charles 'Buck' Krasic</span> 
	  <span class="n hidden">
		<span class="family-name">Krasic</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ckrasic@google.com">ckrasic@google.com</a></span>

  </address>
</div>

</body>
</html>
