<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.42 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-krasic-qpack-latest" category="std">

  <front>
    <title abbrev="HPACK">Header Compression for HTTP over QUIC</title>

    <author initials="C." surname="Krasic" fullname="Charles 'Buck' Krasic">
      <organization>Google</organization>
      <address>
        <email>ckrasic@google.com</email>
      </address>
    </author>

    <date />

    <area>Transport</area>
    <workgroup>QUIC</workgroup>
    

    <abstract>


<t>The design of the core QUIC transport and the mapping of HTTP semantics over it
subsume many HTTP/2 features, prominent among them stream multiplexing and HTTP
header compression.  A key advantage of the QUIC transport is that provides
stream multiplexing free of HoL blocking between streams, while in HTTP/2
multiplexed streams can suffer HoL blocking primarily due to HTTP/2’s layering
above TCP.  However, assuming HPACK is used for header compression, HTTP over
QUIC is still vulnerable to HoL blocking, because of how HPACK exploits header
redundancies between multiplexed HTTP transactions.  This draft defines QCRAM, a
variation of HPACK and mechanisms in the QUIC HTTP mapping that allow QUIC
implementations the flexibility to avoid header-compression induced HoL
blocking.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>The QUIC transport protocol was designed from the outset to support HTTP
semantics, and its design subsumes most of the features of HTTP/2.  Two of those
features, stream multiplexing and header compression come into some conflict in
QUIC.  A key goal of the design of QUIC is to improve stream multiplexing
relative to HTTP/2, by eliminating HoL (head of line) blocking that can occur in
HTTP/2.  HoL blocking can happen because HTTP/2 streams are multiplexed onto a
single TCP connection with its in-order semantics.  QUIC can maintain
independence between streams because it implements core transport functionality
in a fully stream-aware manner.  However, the HTTP over QUIC mapping is still
subject HoL blocking if HPACK is used directly as in HTTP/2.  HPACK exploits
multiplexing for greater compression, shrinking the representation of headers
that have appeared earlier on the same connection.  In the context of QUIC, this
imposes a vulnerability to HoL blocking as will be described more below.</t>

<t>QUIC is described in <xref target="QUIC-TRANSPORT"/>.  The HTTP over QUIC mapping is
described in <xref target="QUIC-HTTP"/>. For a full description of HTTP/2, see <xref target="RFC7540"/>.
The description of HPACK is <xref target="RFC7541"/>.</t>

</section>
<section anchor="qcram-overview" title="QCRAM overview">

<t>Readers may wish to refer to <xref target="RFC7540"/> Section 1.4 to review HPACK
terminology, and <xref target="QUIC-HTTP"/>, Sections 4 on “HTTP over QUIC stream mapping”
and 4.2.1 on “Header Compression”.</t>

<t>This draft extends HPACK and the HTTP over QUIC mapping with the <spanx style="emph">option</spanx> to
avoid HoL blocking.  QCRAM is intended to be a relatively non-intrusive
extenstion to HPACK, an implemenation should be easily shared within stacks
supporting both HTTP/2 and HTTP over QUIC.  For full performance, QCRAM does
require tighter integration between layers, as will be described.</t>

<section anchor="example-of-hol-blocking" title="Example of HoL blocking">

<t>The following is an example of how HPACK can induce HoL blocking in QUIC. Assume
two message control streams <spanx style="verb">A</spanx> and <spanx style="verb">B</spanx>, and corresponding header blocks <spanx style="verb">HA</spanx>
and <spanx style="verb">HB</spanx>. Stream <spanx style="verb">B</spanx> experiences HoL blocking due to <spanx style="verb">A</spanx> as follows:</t>

<t><list style="numbers">
  <t>HPACK encodes header field <spanx style="verb">HB[i]</spanx> using an index that refers to a table
entry that resulted from header field <spanx style="verb">HA[j]</spanx>.</t>
  <t><spanx style="verb">HA</spanx> and <spanx style="verb">HB</spanx> are delivered via distinct packets that are inflight in the
same round trip.</t>
  <t><spanx style="verb">HB</spanx>’s packet is delivered but <spanx style="verb">HA</spanx>’s is dropped.  HPACK can not decode <spanx style="verb">HB</spanx>
until <spanx style="verb">HA</spanx>’s packet is successfully retransmitted.</t>
</list></t>

</section>
<section anchor="how-qcram-avoids-hol-blocking" title="How QCRAM avoids HoL blocking">
<t>Continuing the example, QCRAM’s approach is as follows.</t>

<t><list style="numbers">
  <t><spanx style="verb">HB[i]</spanx> can refer to <spanx style="verb">HA[j]</spanx> if <spanx style="verb">HA[j]</spanx> was delivered in a prior round trip.</t>
  <t><spanx style="verb">HB[i]</spanx> can refer to <spanx style="verb">HA[j]</spanx> if <spanx style="verb">HA</spanx> and <spanx style="verb">HB</spanx> are to be delivered in the same
packet.</t>
  <t>If QCRAM is enabled, <spanx style="verb">HB[i]</spanx> will be represented using an HPACK literal.
Otherwise an indexed representation may be used, but HB must processed
in-order, after HA.</t>
</list></t>

<t>It is worth noting that
rules 1. and 2. are situations where <spanx style="verb">HB</spanx> is not at risk of HoL blocking, even
without QCRAM.  Only in rule 3 does QCRAM come into play giving the encoder the
choice between HoL avoidance or better compression.</t>

<section anchor="header-blocks-fragments-frames-packets" title="Header Blocks, Fragments, Frames, Packets…">

<t>QCRAM strives to solve HoL blocking in the simplest way possible. To that end,
the mechanisms QCRAM defines are largely at the granularity of header blocks, as
opposed to individual header field representations.</t>

<t>QCRAM header compression framing differs slightly from HTTP/2.
Section 4.3 of <xref target="RFC7540"/> declares that:</t>

<t><list style='empty'>
  <t>Header lists are collections of zero or more header fields.  When
transmitted over a connection, a header list is serialized into a
header block using HTTP header compression <xref target="RFC7541"/>.  The
serialized header block is then divided into one or more octet
sequences, called header block fragments, and transmitted within the
payload of HEADERS (Section 6.2), PUSH_PROMISE (Section 6.6), or
CONTINUATION (Section 6.10) frames.</t>
</list></t>

<t>As with other aspects of QUIC, QCRAM aims to leverage opportunities for tigher
integration between layers, in ways that may not have been practical in HTTP/2
due to various forms of ossification.</t>

<t>QCRAM header compression SHOULD be progressive: compression of a Header List
should happen iteratively, where each iteration produces a single Header Block
Fragment constrained to fit within the space available in the current transport
packet.  The Header Block Fragment will be encapsulated by an HTTP mapping
Headers Frame (HEADERS or PUSH_PROMISE), and the Headers Frame will be
encapsulated by a QUIC transport-level STREAM frame.  An implementation that can
not support such coordination MUST forego references allowed by rule 2 of the
previous section.</t>

</section>
<section anchor="absolute-indexing" title="Absolute Indexing">

<t>HPACK indexed entries refer to an entry by its current position in the dynamic
table.  As Figure 1 of <xref target="RFC7541"/> illustrates, newest entries have smallest
indices, and oldest entries are evicted first if the table is full.  Under this
scheme, each insertion to the table causes the index of all existing entries to
change (implicitly).  The approach is acceptable for HTTP/2 because TCP is
totally ordered, but it is is problematic in the out-of-order context of QUIC.</t>

<t>QCRAM uses a hybrid absolute-relative indexing approach.  Every QCRAM header
block starts with an integer that conveys an absolute base index.  The format of
individual indexed representations does not change, but their semantics become
absolute in combination with the base index.  Similarly, the base index is used
to perform table insertions at unambiguous positions.</t>

</section>
</section>
</section>
<section anchor="changes-to-hpack-and-http-over-quic" title="Changes to HPACK and HTTP over QUIC">

<t>QCRAM is optional on a per header block basis.  QCRAM enabled header block can
be decoded on receipt, otherwise the header block should be processed in strict
order as per Section 4.2.1 of the HTTP mapping.</t>

<section anchor="hpack-changes" title="HPACK changes">

<t>QCRAM adds three integer <spanx style="emph">epochs</spanx> to HPACK state, all derived from the sequence
numbers of HTTP Mapping (refer to <xref target="QUIC-HTTP"/> Sections 5.2.2 and 5.2.4.), and
provided to the HPACK layer by the HTTP mapping:</t>

<t><list style="numbers">
  <t><spanx style="verb">encode_epoch</spanx>: the sequence number of the frame enclosing the header block,
as per the HTTP Mapping.  When entries are added to they dynamic table, the
current encode epoch is stored with the entry.</t>
  <t><spanx style="verb">packet_epoch</spanx>: the first encode epoch in the current QUIC packet.  When
multiple header blocks are packed into a single QUIC packet, the header
blocks should be ordered.</t>
  <t><spanx style="verb">commit_epoch</spanx>: the highest in-order encode epoch acknowledged to the
encoder side.</t>
</list></t>

<t>The following must hold: <spanx style="verb">encode_epoch &gt;= packet_epoch &gt; commit_epoch</spanx>.
Section 3.2 describes ho the epoch values are computed.</t>

<section anchor="indexed-representations" title="Indexed representations">

<t>As each header block is processed, HPACK is informed whether QCRAM is enabled.
If so, the encoder will emit an indexed representation only if it is not
vulnerable to HoL blocking, that is if there is a matching entry in the dynamic
table such that: <spanx style="verb">entry.encode_epoch &lt;= commit_epoch or entry.encode_epoch &gt;=
packet_epoch</spanx>.  Otherwise a literal must be used.</t>

</section>
<section anchor="indexing" title="Indexing">

<t>Every QCRAM header block must start with a single HPACK integer that encodes the
value of the base index, defined as the total number of entries that had been
inserted to the dynamic table before encoding the current header block.  As
described above, the decoder will use this as the starting point for insertions,
and for interpreting indexed representations.</t>

</section>
<section anchor="table-evictions" title="Table evictions">

<t>Since QCRAM allows headers to be processed out of order, it might be possible
that a header block may contain references to entries that have been evicted by
the time it arrives.  For example, suppose HB was encoded after HA, and HB
evicts an entry referenced by HA.  If due to network drops HB is decoded first,
the reference in HA will become invalid.</t>

<t>To handle this with minimal complexity, QCRAM takes the following approach: if
<spanx style="verb">packet_epoch &gt; commit_epoch + 1</spanx>, and if while encoding the current header
block an eviction becomes necessary, then QCRAM must be disabled for the current
header block.  The first condition might be paraphrased as: are there any header
block packets still in flight before the current one?</t>

<t>In the above example, HB would not be QCRAM enabled, hence the decoder must
ensure to process HB strictly after HA.</t>

<t>*Compared to other QUIC state such as receive buffers, the default table size of
4,096 octets (see <xref target="RFC7540"/> Section 6.5.2.) is very modest.  Deployment data
suggests it is rarely increased in practice, and experiments to increase it did
not yield significant gains.  Consequently, I think it’s best to avoid any
heroic measures to deal with performance under full tables. *</t>

</section>
</section>
<section anchor="http-mapping-changes" title="HTTP Mapping changes">

<t>An additional flag is added to HEADERS and PUSH_PROMISE (refer to Sections
5.2.1. and 5.2.4. of <xref target="QUIC-HTTP"/>):</t>

<t>QCRAM (0x8): This header block can be decoded upon receipt.</t>

<t>When encoding headers, the HTTP mapping layer notifies the HPACK layer whether
QCRAM is set, and provides the commit, packet, and encoding epochs:</t>

<t><list style="symbols">
  <t>the encoding epoch increments for every new header encoded.</t>
  <t>an encode epoch is considered acknowledged when all the bytes of the
corresponding header block have been acknowledged.  The mapping layer keeps
track of header blocks by their encode epochs, and monitors transport
acknowledgments to determine <spanx style="verb">commit_epoch</spanx>, the highest in-order acknowledged
encode epoch.  <spanx style="emph">This piggybacks on existing QUIC transport mechanisms, no
additional wire format changes are needed.</spanx></t>
  <t>the mapping layer coordinates with packet writing to manage space available
for header blocks, and advances the packet epoch at packet boundaries.
<spanx style="emph">Although sub-optimal, a simpler implementation could ignore packet
boundaries and hold that: .</spanx><spanx style="verb">packet_epoch == encode_epoch</spanx></t>
</list></t>

</section>
</section>
<section anchor="performance-considerations" title="Performance considerations">

<t>Beyond sequence numbers already defined in Section 5.2.1 and 5.2.4, the only
additional overhead of QCRAM is the base index added to header blocks.  For a
connection with fewer than 256 requests, the index would consume 1 byte per
header block.</t>

<t>It might be advantageous to allow implementations to send header frames on
the HTTP control stream (QUIC stream 3).  Such headers would not be associated
with any HTTP transaction, but could be used strategically to improve
performance. For instance, as a means to avoid disabling QCRAM because of table
eviction, or to ensure most frequently used entries have the smallest indices.</t>

<t>For QCRAM header blocks, the base index is sufficient to decode correctly.  If
QCRAM were made mandatory rather than optional, then it would be feasible to
remove sequence number from wire format of <spanx style="verb">HEADERS</spanx> and <spanx style="verb">PUSH_PROMISE</spanx> frames,
as well as the QCRAM flag.  However, this would imply that once the table became
full, insertions could only occur during during periods with a single header
block in flight.</t>

<t>Alternatively, if it were desirable to support a middle ground between totally
ordered HPACK and the present draft, one way might be to extend the concept of
packet epoch to denote a sequence of one <spanx style="emph">or more</spanx> packets.  A pair of new flags
would be added to header frames to signal the start and end of such packet
sequences.  The decoder would have to have buffering based logic to ensure
header blocks within a packet sequence are processed in order, similar to the
logic used in totally ordered HPACK.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>TBD.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document currently makes no request of IANA, and might not need to.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>This draft draws heavily on the text of <xref target="RFC7541"/>.  The indirect input of
those authors is gratefully acknowledged, as well as ideas from:</t>

<t><list style="symbols">
  <t>Mike Bishop</t>
  <t>Patrick McManus</t>
  <t>Biren Roy</t>
</list></t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="QUIC-TRANSPORT" >
  <front>
    <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
    <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
      <organization>Google</organization>
    </author>
    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Mozilla</organization>
    </author>
    <date />
  </front>
</reference>
<reference anchor="QUIC-HTTP" >
  <front>
    <title>Hypertext Transfer Protocol (HTTP) over QUIC</title>
    <author initials="M." surname="Bishop" fullname="Mike Bishop" role="editor">
      <organization>Microsoft</organization>
    </author>
    <date />
  </front>
</reference>




<reference  anchor='RFC7540' target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor='RFC7541' target='http://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
H4sIAM9V2VgAA51bXXMbt5J9x6/AJg+xtSSv7TjZvayNdynZWeneOPa15NqH
VCoCZ0ASV8MBM5gRzaTy3/d0N4D5kOLaWlcqlsgZoNE4ffp0A57P56p1bWWX
+tKa0jb6wu8PjQ3B+VpvfKMvb27ea3+Pb/7x8epCmfW6sfd4+v3q4u+q9EVt
9ni5bMymnd81Jrhi/uvBFHfzyrQ2tKrEX0v9++vVzZs/VIFftr45LXVoS+UO
zVK3TRfaF8+e/fXZC2Uaa5b6pjF1OPimVUff3G0b3x2WMrkKranLX0zla4x5
skEd3FL/1PpipgNeaOwm4KfTXn6AdXtzOLh6+7NSpmt3vlkqPVcaf1wdlvpi
of/OJvNHspKLnWkqG/RX511x99Xwe99sl/q/vd9Wln+3e+OqpS5k1f+15W8W
hd8rVftmb1p3b5cKj5Lt85sPqx+v37/7cLPkl6PTv6DvlnqlP75+Pz83wZb6
bVe17lDZT/gZq9XXtuga23vlC35/5Fb6IK+P/8zj33Ghf1voq5Ott6bJn8tq
/2Zq8+Cr6ULpT+PJXFu61jePz/F2oW92fh98PZnjrWlaVz/4kmd5639zVWUe
nya5jiA49trl6WCb1n5qxS0boPN944EDX+kn9PjTHrL/H39hLecu7PxhuhR3
Z6ffyDpc0fjgN+2frGQ+n2uzDm1jilapm53VpQ1uW2u/0S1+Kzy2mKxFPMR9
5s2n7yKG6VEOxgDg1a0rgqzRtSp069Dt6cn6xM/85YXeWNMCNwiDQ+P3rrY1
Rtx7jIMx94g/xNpe7xPYaAKakN5WO6GCoqeChQZG7+xJm/Iek5utTZZPjHYB
n5qWJr13WKN6bKJNY/n9S/+DXle+uKMP17Y9WltHy2D3cecqi/2IK1L7QWDE
h3Rh8EK3IQCMBjs0bm8aV5102Vnd+jjGV0FX5mQbPAImg/v0zcV7rO3SHy18
OdMmwJE0APMbraajmCQifOiUWU+Oit2Ax0MLPOv7rqptY9aVzD2wbIZ1FgaD
0vp3/hgnsp8OlXdtiLOoxpZdXZq6cKCi5JmhA3hmdjsQBVsCVnGzgwHMxEDX
Blse9D8uPqzeYlnqHt4w9CD7neek7d7bYmdqF+BKODrvJ4+ecMf7aaoKxjIL
uz1s2ANPPF7gtza0s2tXufZEKzb33pVxLfOBxzBJ2RVkvv9BJZcsJDz2rixB
OOpLfVW3jcdzNLwEywRkhxTrRxNiINEmAedsjO/aYFuyI3QHfoFRneNmxksn
b8cgjPET9N6HNgE7BVCKu7+8IBcfvXzvg1V9iP1ZND3EDP1MoCbj6KfC15vK
FQicmjGUA23rTZVM6bkiwQyvYxsaQvAjcwM+FaefHvnA3UnbygHc+IYADlA+
Ifto2ApgedpHD+84hZYvkHvItOyAUZTRIzugBNhMqI7sk+ITGX0EW08LNyrg
7YqDjxxQW95qfXTtjrfF1XPfkOPyli0kFfCMSLvAHowCmCzmLm1d2Cl9ZINc
qzNgg/BsD6RNV/PUhoCL8bTBRxVYQ0aZmyMvwMDEZkgTtCljYZSjJXEAkfI/
sbCxx9xmwiyla/AQZjShpzqaakQLakyfYKMt7GundBR2YLa4g1Y3lr5Jccp8
w3AMivd3Z4AP2jwssdT4f+UwnhcWCEawGbcGBl3VMVHVnHcjFskVLhAlICCw
3Zn5MhWMlo9FHokf14zponFrTL2nPVlb8AuYIAG8/xpe+f33sYT64w9mu8/s
gXrsfXqaXv0e/pONjtMcMjHGWAnIT7///i8fvr/4t29ePsM7KWWPHk4bmZ98
Tk+CwJh12a57Z49KfRC/w74T1h925BdIVJiNH4bzkNjj4Z8vXspDNEAU29hu
RK+v/PYkDDZa1iy9G/RL2sUvJr5JNCEu+kLRAC8XLxbP5eEH4v+LBVFvTijY
c0RaGKSOz8QABzJ9f+bZW2dYi5KcMIQDBTV7yhH2aXxsF1YNdBidKAyhUft6
ju9RKOB3xZYE9hLBi+whd+QoF7RDonVVSUNZqHOK6B3jnExzxBIoUSBOJD+w
/PCwObJXEkL90mAqoYYxA+m5IX0P1pnFBZQeSqexv3aO6MVtdxSatKRtI+Yk
dmL1QQnokUAg6Hyp33wytJCpPJI8uPGUhiPNYM22f7jXEsSRkmcn3FPHpaxI
5FjVIpch6QUScxTWUKyZPW9Xt+yF2/NbwRqIE8A4+LqkoWJe46Hx8OXqlvF0
e3l+u9DXgjS8SvwFsUX8HMa2RFXG04S4rIBi6fkiMV9deHgmzbRxtuLxf3I/
34I5JcHSMu0nSVccT5wYjW5JeZESB/k1p/R9AIcmmTAZdvXTP3++XSgQL61F
p7Vw+iqRNQEDvHnvDPga0EPS0FTj2jaqXXrOUSLHzkchRdMzi6J+pWgBcWCD
v17wwNCh8r5QXZpg3bVsAL7mwPNg5zInA9rX2pO2I9fwODRJhwRZpdf6UUNX
wOtB0lljOeftXdsmnF2SnGPwcmCO90ddAA+u7lIqiTiLcMc8CPTGm2LHOMwb
uOANTLtE9maWiz6mBJh+FPGW1s7JF7IdUTb02Iv/03iTLRMOGY2dkhp5TJy0
oM242vQUBOoAbMpZnjBFaE6kGCpDT/YEWQ7ZrlrQsO8wRwN6txmZeH6ShCkD
YERK/TPe7stz6KPAkpa2y5aKa1DRPwi9DTHJ5QqeveJtPYKudgSDpNNU01G7
An4nF8Bd5IDg2i6q8yOMErDQ64QfCgYX7qYMM9PQNrUigoSAFrcAe+9q4AcO
pGn018x00WW9kj2A1vTW3We4cPA2HAbFzruBPKMZGXBEn6id6YuJjmF8fpn6
UefMMTP9fWO2rOH4xz2p7vcSgosF6QY2CfSFLWcWCL66f0iADAPOFPD5EVZD
twSHbV/oGy+xjDQ0U1x397VRZPlYVJGHK9NsKTfhBXoWPF93+IxETxZakR+J
7RVC2QdJb4AGXFV20PcjGhpDJeRFPVJEbOABplG3YdYLzDwwh8ktikiVxMTL
xddk1EhogERgrhX+AvG+Sv6uQHCyRBRYVZIUeP0323jaMJZrQ8NJnP/PDtB5
pQcsI7nTDEQk/JDeo0mYpJAdoL1/4xjlyuDVyHcx3DgXP+KGkfBiRYj3B2OO
huLOBBDIzk8T+trmNfmitS0P8GvHKWsGyoELJuNseiCyDBosOYqLlu04mFPl
pby6fLN6/ebDtX6SduTbxYunwO/H68tf3n949/bq+s3wu2/xnW8wxMW7H2+u
fvy4url69+PwgefPnjIELIFkFURveaIfQO2Ax0KvzyPHuz1HRUX1C3dvWPh0
tWupw0AVBckW26jPqRasDTETcx5RGdEJ1xFreuxA3S0Hnw2aNjHRU/vBdzzR
no2jsNvg2VYC/k+Rfn357uMPr4kzwZBb/vTeLkePYDST0PsDgKWi9ouVKTO0
KMlZZEPLmUs+92Q3dRu4fImF6ZB7VGIegjJ18FwtcbxBadnvuA5IK6D+e+Mq
bvzEj1FAN/RyLjpVTD+xghnMlDkuZx7A0BygWwyhCwW8qUetGXUZCwtmRP0k
4Qy7OcTW01kv2EcvxGnUg2kmDZc5wabS1zcf3mCXGHnUp+g1d8xuqW+gCBep
9wIhsoPrkNBc1OZvP17fEBLsNpZBIhC5xSQGcLJ5Edsf6kBlEKEnxGpUEsRq
DY7vWovStJS2h4olWcy9pP4I3Vk0kGJmRYgpqM+Q9gbU7FppT0m/5VSDXwvF
OpJWCoe5LXXhn4+IFLSj4cKOUNESX9T2SIklTcyhEfZEIoAl8T6zCm2Gr8rh
k8S3WGTBAtU1xI7S+mkFS4FLD5jysZbEihI3FDv4fhbRXIP3UlHUv8g9EGnR
iVamYMGmw1+BJUQyAAUaZTswwxPaVFc4pJOnEaQjtQdZeZDB0/EQKqbUbaGO
DkxrfWtId7KKSVLHMeXjPwyG1+mApEgeh+KY+03s+kx6DJkeOmkx7E7rBpWk
ids/z80uF3GQ7YX5b8B3Jz2kF+k7UgXYtJE6Wa+B9tizhgP93p64wkqz6LUJ
cYboFK4ByUg1SOiPy74gsomiQpwsDsHC3aDHRU6EpFJ5SsfdwnUKm1xVj0y5
dnsQTkPkNv4utZgUCTQpWROaElYCyZcOWF8D3RRgKRACtzEu2NaQy+xH6uK0
NZhLSn1qWrKSt804bcIwF3LFH7X2+BFiDtbtpB6pVwg3FtYd2pkkN9bWtMjR
W32lnzW05gq/QTgpQRQqDTKoF0Tc99j0PYxIqLE0knJLVp9WaMqS4ohOLhJW
zuzBF7tw1jsIoGqxuYY7SyRFB13pJCtU3e3XxMHpPOdt7Jo8GbSEBo2dvq/z
DcyW5gT99HIhvK7iUUuZIj9WJpSzieima5Qq+1Y0+i+8hNvlyEItFuZGOOcK
fFH5kBT+cAdmVLJED+fJ4qKiNBzxHDyZjT0lrhVozlLlnJhZrNRspbRWferi
xEoDdC5VoqTV0YKEScdjjLMy57mckFnFYvbUbZ30Och4fjap1SQXBqPMBu6h
oeKrPUgjJXL1eYvwhnQc2bwjGUb8n3rgI/MxR+2PiJxtdqH0OaTgCsDBYtoq
4vpyh4SzHO+6fvWdHjpNv9Ije/oC4mvALrWpkNUEZvLOvak6m+qF/aFL/YUv
JSs/pEIWrJyypuo8h++sb626mniLdnxnWd9Oq/WFQgkf/GxUd7KusVjJZypx
z3XtJmYlULP63KEdpwWyh0Oi4YxsEFFtsUtZ9PSoehD5w0UWeZ/QOtqD//hu
5HSSbo889eo7NYL3YtRtSF0I2enYXhjuAmujh5kwup7f4nQYs2FWwVFNDTJj
assR7njrE0n0eWcW6+SSOIGVCImBAadkySGnECUXD0qSUs9iI17AI6QXZfrE
QSmGh4thsTZo/vMh7yweog3A0XEmkeYVU19rpA188FgvK5s+S864uSmfwdGA
USvthEcBHh1/w3azphPYXzui1phMuF2WzmNiv6pPX9R/oRpJekBA6J4bi/RM
bFfIEY6ZbCQqMtJOxtVDXY3RJy5PBVtSnOsTNzxat+fzMtNwFyX2vHPvjwU9
HfGdc+tOoFDmFpXo2stzxaOGXmxnU1jaX67oMGmTOsA1Skzf3HGzM9DQ3BCV
kZm+pReTx+DScpUql9iCAhIdAf7GY3F1WcW9ZTTvXe2gwJmd6PysPaWauDV3
URr3XJmU4xKRrm4/w476X/Xz2BoHJ8hVhc+gM4pOU2dEROtBPZZ23TQi4Opo
XArl0gVRSlyi9+OqCepvcrorqEcvzcaMGtOYw67h60UmLKVHyjRGF0ZGFqa2
ttxjgLNjUzsG4HBlvrb/qVQ8F5TbFBkrhBHOeKR513as+maYkrZyGJW0XtSh
oZP2bYwFGkeEHLXa+l7oGR1U8XkO9XAkMcghF/SXUK4Joh4J63xBJCQa2Bik
98grwf1GFKZezp799VvpAAX9ZHr8p/vWCymvpwRSZtM9kSEph9f2UPkT1+6l
aY0K3RbakY6yOW00sJXbqEVjTRSosVtiBURyUiKH1NwjlCfp/dKVXFCfuEtI
NwG4c4Kptoh0CtMLEAxrt5bKgCtCf42U2n5FNUVo+xsZ2G4Ap/Hg1T2G5+sN
+LK0CBCOlsHZFgoDbvHRkRc7CzOdiT4eqtYsk1c1KTsXi4BNZeSQKom91Jug
xY4bX1n2JqGryMmxoS1KV6rugSh+uky6/MmzT//+dCl3X6bVhB5UE92hryeA
oKhKY8BGIh4c7KejTJHR1G/fuMgWQ30dZUlfBQWSgGR4ugAVT82JOWZZI/KO
p8mlisCCznoRkz8XJAguiAIs4662x7TYSMMUFEK5Y8FMPSvHinOsHY+0fqpT
OHmfWrnnInLyz8/6BrljOFrkn7HP7qw9BIxGd97uHjTFY2Xixvo2Nkf2vqZr
c2HQNNODCXOUlFbOxO1ESc8eV9JDk5UeTYwVnDGEDm67Pa3pcJjqz9wmmVxA
6o8GZsAGGdcj/0hnwLE5EIODCbe2lvbpLO3z2Fu5QWZj3oonecfGyVGPp2so
1Lmd9Bkx+eB2Wj5xgBf5ql4RERiHi1VEOr7UazpqM6QN6AjrbFXR4c92Rzei
5lTQI3POWBASrTfTfl/BFA9C8qkyoo3qx5Q7UKg8kgAeJdTvvtOjIpRc86V+
P2CgBN5UOZzbE0A5rVOpcwiyLE9ZeIJdE2MzlfRMIsgg7a8GW0btjHQVKkfy
pJuSiWzk6aiRjJpeY9rYo2jmWr/45ltNdwMoH8wGrThJkLRGurv5nKOQCHic
2vngL2fyfP2SujVE63wt78GNPA8f9dfP5KgAq1aZ3sbn/frJ8IrI19T2u+5y
hRbGqdyE4AtHrWIVm2enB7cRpb9VpJqXbzpJk3RL5wPVaXCBTQ1yjtzNQVJr
5XaF4SrLGlmT5DBRRByUvFWD+5Ry7p8UFh2iiPhlVcF3+zZNypNi1KhTy4VA
7Nbq2K2F/8mkh2VTeKzfRldRXeG43+/TQT3TKSkYFr4xVRwtXywr+XYZJIMn
oWxYyTBoUjctikI6akje3NCNFqlSFVID3wGcdG646TQkIk/H5JKB41n5MAff
Roig0MFmW2SFWBaJrZTLx7ffXMIEIS9esPBJ0qWKraDjdpIPs2HHUUDB1bfc
Liy7Rm6E8F+kgnwZJpXoSKJmUUqHXxUyQJ2Pd6SeZ9/SnclczKezCBNvmeqt
3DFIB1yxX61ic2ZyyymWd3ITasZnhnR0nIOSMMbXo9INOeqQk6ockS4DAjFE
BXveL6ryaronJWeQZ0l/8zXQg3FcMFO2pz0IKmNgykYxxGmpoGNT9UVt1BrM
bSyMI0/nU86YvHN5HM/O5PKo5HvWz3xJisVr5bdUmKfIUuPEHo/ETEoxea3c
Phu2aGN9G6SDndpZMnoXn5mcJMjOcHea/10EnbdfTLLEzflrfuBq9ePq4Zd8
pc0XnZzoSSmD8fdcDNY+MTW5iwaIgoS3mgiQsjiM4glWY0Uyui+H/0uBf0+X
z+KtynSq8fDcmumGWAI/HLj6V3zHOP4zBT42oVNZK/d5hkpGLpPFoMVS6ToO
wp/15PDfK+DX94ZqqTv9tnhr6i7QR+eYtdYf/Ekp9b8UHrC/DTQAAA==

-->

</rfc>

